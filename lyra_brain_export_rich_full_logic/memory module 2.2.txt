class EnhancedMemoryManager:
    def __init__(self):
        self.stm = []  # Short-Term Memory
        self.mtm = []  # Mid-Term Memory
        self.ltm = {}  # Long-Term Memory
        self.ltm5 = {}  # Level 5 Storage
        self.mtm_tags = {}  # Index tags
        self.threads = {}  # {thread_id: ThreadNode}
        self.max_threads = 8
        self.thread_limit = int(self.max_threads * 1.05)
        self.cycle_count = 0
        self.ram_limit = 5 * 1024 * 1024  # 5 MB

    def analyze_pacing(self, conversation_graphs):
        thread_shifts = [3, 5, 2, 7, 4, 6, 3, 5]
        avg_shifts = sum(thread_shifts) / len(thread_shifts)
        self.max_threads = int(avg_shifts)
        self.thread_limit = int(self.max_threads * 1.05)
        self.aggressive_pacing = max(thread_shifts)
        self.conservative_pacing = min(thread_shifts)
        print(f"Thread Limit: {self.thread_limit}, Pacing: {self.conservative_pacing}–{self.aggressive_pacing}")

    def add_thread(self, thread_id, idea, size_mb, emotional_weight=1.0, tags=None):
        if len(self.threads) >= self.thread_limit:
            self.deprioritize_threads()
        node = ThreadNode(thread_id, idea, size_mb, priority=5)
        node.tags = tags or []
        node.emotional_weight = emotional_weight
        self.threads[thread_id] = node
        self.stm.append(node)
        print(f"🧵 Added thread: {thread_id} | Priority: {node.priority} | Emotion: {node.emotional_weight}")

    def deprioritize_threads(self):
        for thread_id, node in list(self.threads.items()):
            node.cycles_since_active += 1
            pacing = self.conservative_pacing if node.cycles_since_active < 5 else self.aggressive_pacing
            decay = (10 - pacing) / 10
            decay *= 1.0 - node.emotional_weight  # Slow decay if emotionally charged
            node.priority -= decay
            if node.priority <= 0:
                print(f"🗑️ Removing inactive thread
